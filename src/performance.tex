As mentioned above there are two factors we want to minimise when doing
optimisation, generated code file size and runtime performance, in this
section, we summarise our findings for each of those aspects. In the case of
the membership test, we also try to find the optimal number of comparisons from
which generating the subtype array is beneficial. This variable is represented
by the $limit$ parameter, where a $limit$ of 0 corresponds to the case where we
always generate the subtype array.

\subsection{Generated code file size}
  This was the easiest aspect to test. We looked at two different programs to
make comparison. The first one is the historical Scala.js example programme:
Reversi.scala which is a good example of a small but real world Scala.js app.
And the second one is the Scala.js test suite which generates a huge JavaScript
file and thus give us an example of how bigger programs would react.

\subsubsection{Methodology}
For each of the tested project we simply ran the sbt commands \emph{fastOptJS}
and \emph{fullOptJS} successively and looked at the file of the created
JavaScript files.

\subsubsection{Measures}
Figure \ref{fig:file_size} organise all the different file size measured in
Bytes.

\begin{figure}[H]
  \centering
  \begin{tabular}{ | r | c | c | c | c | }\hline
    & \multicolumn{2}{|c|}{Reversi.scala} & \multicolumn{2}{|c|}{Scala.js
testSuite}\\
    & fastOpt & fullOpt & fastOpt & fullOpt\\ \hline
    Current Scala.js master branch & 538'088 & 123'708 & 21'385'239 &
4347723\\
\hline \hline
    Constructor inlining branch & 519'886 & 117'508 & 20'669'926 & 42'293'350\\
\hline
    Difference with master & -3.38\% & -5.01\% & -3.34\% & -2.72\%\\ \hline
\hline	
    isInstanceOf branch (limit=0)& 501'495 & 120'046 & 21'078'724 & 4'381'011\\
\hline
    Difference with master & -6.80\% & -2.96\% & -1.43\% & +0.77\%\\ \hline
\hline
    isInstanceOf branch (limit=1)& 0 & 0 & 0 & 0\\ \hline
    Difference with master & 0 & 0 & 0 & 0\\ \hline
\hline
    isInstanceOf branch (limit=2)& 0 & 0 & 0 & 0\\ \hline
    Difference with master & 0 & 0 & 0 & 0\\ \hline
\hline
    isInstanceOf branch (limit=3)& 0 & 0 & 0 & 0\\ \hline
    Difference with master & 0 & 0 & 0 & 0\\ \hline
\hline
    isInstanceOf branch (limit=4)& 0 & 0 & 0 & 0\\ \hline
    Difference with master & 0 & 0 & 0 & 0\\ \hline
\hline
    isInstanceOf branch (limit=5)& 0 & 0 & 0 & 0\\ \hline
    Difference with master & 0 & 0 & 0 & 0\\ \hline
    
  \end{tabular}
  \captionsetup{justification=centering}
  \caption{Generated JavaScript file size in Bytes for fullOpt or fastOpt with
the size difference.}
  \label{fig:file_size}
\end{figure}

\subsubsection{Observation}
Both optimisation have a positive effect on the file size of the generated
code. Where it seems logical for the constructor inlining it may seem
strange at first for the isInstanceOf optimisation but as explained previously,
the increase in size caused by the subtype arrays is counter balanced by the
fact that we were able to change all of the ancestor fields from objects with
long string keys to packed arrays of ints.

\subsection{Runtime performance}
Gathering valid and relevant data for this criteria was a bit harder than for
the file size. As described in section \ref{scalameter}, it can be challenging
to collect meaningful measures on runtime performace impact of code
transformations.

\subsubsection{Methodology}
We used the ScalaMeter framework, that we previously ported to Scala.js, to
measure the impact that our transformations had on the runtime performance.
For the final classes optimisation, we created 3 * 1'000'000 object on every
iteration of the test, whereas for the instanceOf optimisation, we perform
roughly 8 * 1'000'000 membership tests for every iteration. We report our
results in the table below.


\subsubsection{Measures}

\subsubsection{Observation}
